Want to make a minimum SQL database
- SQL-87 (nothing fancy)
- Simple datatypes
- 255 character varchar limit
- 32 column table limit
- One database per file
- No transactions
- No foreign keys or other constraints

1. DataModel
2. Execution
3. SQL Parser
4. Benchmarks against SQLite

Let's start from the bottom: columns.  They have a type and a name.  In the future they may have more

Then we define a row.  Rows have an array of column values

Finally, a table has an array of column types (up to a fixed limit) and a pointer to a bunch of rows.  Oh, and a table name.

OK, now that we have the basic definitions out of the way, we need an API to manipulate them.  First off, we need a way to create and drop tables.
We should try to have the API mimic the eventual schema definitions as closely as possible.

>>>>6941ff<<<<<

Autoincrement column type - but now we have the first operation that could generate an error due to user action (and not some program malfunction).  In this case, it's trying to set a value explicitly in the autoincrement column.  We also have another problem: to keep our API simple, we pass in a simple array of the values.  So how do we pass in a "value" that's not really a value?  It's time for an IGNORED type.  Next problem: how do we keep track of the last ID used for each?  It would be a pain to search the table everytime we needed it.  We could store it directly in the table, but what if they had more than one autoincrement column?  Solution: store it in the Column Def!  But it seems hacky to put something in there called "lastAutoincrementNumber".  I hate data members that are only valid for a small substate of the object.  Why don't we do something a bit more elegant and just always store the last inserted value in the Column def?  That would still serve our purpose, be far more elegant, and may come in handy for other uses down the road.  Perfect!

>>>>ee41a0e<<<<

Now that we can work with some basic table operations, need to create the concept of a database.  For our purposes, a "database" is simply a thing with a name and a bunch of tables.  This is easy enough to create, but we also need to modify the existing API calls to know about databases.  For example, when you create a table, you should create it IN a database.  While we're at it, let's make the API more consistent by returning Results instead of the objects.  The objects returned will be an out parameter. Had to rename InsertInto to InsertRow() because we will have an InsertTable() function.  We also have our first private helper method, so we differentiate it by naming style to show that it shouldn't be called as a public interface.  As an architecture note, we now notice we're doing the whole "see if we have any more chunks left, and if not allocate some more" behavior in two different places.  Only the names have changed.  We won't do anything about this now, but we take note of it and consider it as a possible refactoring to remove the repeated code.

Next, we need calls to drop the database and print it.

>>>>c5fc8dc<<<<

Before we start to implement some of the more complicated features, it's time to do some housecleaning.  So far we've been able to do everything in one file.  We don't even have a header file.  I highly recommend starting this way so as not to "over engineer" your program ahead of time just for the sake of picking the right file names for your classes/modules.  But now the program is getting bigger and it's fixing to get a whole LOT bigger.  We still don't need to start breaking out separate modules or anything, but what we DO need to do is separate the public API from the implementation and internal functions.  

So what should we call our first file?  Well everything we've done so far has been database engine internal stuff.  We can anticipate other things down the line that will use this interface (such as the SQL language parser).  So let's just call it "engine".

Now that we're thinking in terms of APIs for other programs to use, we need to be more considerate of the global namespace.  Renamed LIMIT_* to ZDB_LIMIT_* and RESULT_* to ZDB_RESULT_* and so forth.  For a real world example of an API that does this very well, check out GTK and GLib.

I also used this opportunity to get rid of a bad habit I had.  I learned most of my more "advanced" C programming from Andre Lamothe's classic "Tricks of the Game Programming Gurus".  He would always define structs like:

    typedef struct SomeType_tag
    {
        // ... struct stuff
    } SomeType, *SomeTypePtr;

    I have no problem with the typedef of a specific pointer type (though I don't use this style myself).  However, the declaration of the _tag is now archaic and unnecessary.  I've known this for a while but refactoring periods like these are an opportunity to work to change old habits.  So now my struct defs look like:

    typedef struct
    {
        // ... struct stuff
    } SomeType;

    MUCH cleaner.

Renamed all functions, constants, and datatypes.  Now it's time to move the code to the engine file.  Now look at main.c.  This is what you want to see.  A file that expands and gets a little messy while you're coming up with ideas and creating the code, then it gets smaller and tidier when you refactor.

It's also important to remember your audience when programming.  Unless you are programming the top-level part of an application (that actually shows stuff to the user, for example), the code you're writing will be used by other programmers, and they are your users.  Just as you should be considerate to end users by making your application user friendly, you should also be considerate to your programmer users by making a friendly API.  Proper and consistent refactoring is a great way to do this.  One reason is that the code is no longer sitting in front of you in the same file.  So now you get to play user and dogfood your own API.  Remember: just because the only other user of your code may be you, it doesn't matter.  It'll probably be long after you wrote the code and you'll be in a different frame of mind because you'll be coding at a different level of your codbase.  By kind to yourself.

>>>>COMMIT<<<<<

Basic select support.  The way we'll flesh this out is to start with the simplest possible query that involves a table ("SELECT * FROM table") and make sure that works.  Then we'll build upon that.  All queries will be executed using a "forward-only firehose" cursor technique.  In other words, until we need to do something more advanced, we'll just iterate one row at a time and see if it matches the query parameters.  If it does, we'll return the row, if not, we'll go on to the next one, signalling when we're at then end.  Now, keep in mind that the results of a SQL query look an awful lot like a table, so why not reuse the existing table infrastructure to form our results?

Print out the results in a pretty fashion
Expand the Results to be a struct that includes rows affected

Adapt API much closer to SQL syntax using varargs and such.

>>>>COMMIT<<<<<

Update support
Delete support. When deleting rows, we'll just mark them as deleted, then we'll have a COMPACT statement that goes in and cleans them up
Compact support

>>>>COMMIT<<<<<

Joins in selects

>>>>COMMIT<<<<<

SQL parser

>>>>COMMIT<<<<<

REPL and read from file

>>>>COMMIT<<<<<

Benchmarks against SQLite

>>>>COMMIT<<<<<

Improvements based on benchmarks (indexing?)

