Want to make a minimum SQL database
- SQL-87 (nothing fancy)
- Simple datatypes
- 255 character varchar limit
- 32 column table limit
- One database per file
- No transactions
- No foreign keys or other constraints

1. DataModel
2. Execution
3. SQL Parser
4. Benchmarks against SQLite

Let's start from the bottom: columns.  They have a type and a name.  In the future they may have more

Then we define a row.  Rows have an array of column values

Finally, a table has an array of column types (up to a fixed limit) and a pointer to a bunch of rows.  Oh, and a table name.

OK, now that we have the basic definitions out of the way, we need an API to manipulate them.  First off, we need a way to create and drop tables.
We should try to have the API mimic the eventual schema definitions as closely as possible.

>>>>6941ff<<<<<

Autoincrement column type - but now we have the first operation that could generate an error due to user action (and not some program malfunction).  In this case, it's trying to set a value explicitly in the autoincrement column.  We also have another problem: to keep our API simple, we pass in a simple array of the values.  So how do we pass in a "value" that's not really a value?  It's time for an IGNORED type.  Next problem: how do we keep track of the last ID used for each?  It would be a pain to search the table everytime we needed it.  We could store it directly in the table, but what if they had more than one autoincrement column?  Solution: store it in the Column Def!  But it seems hacky to put something in there called "lastAutoincrementNumber".  I hate data members that are only valid for a small substate of the object.  Why don't we do something a bit more elegant and just always store the last inserted value in the Column def?  That would still serve our purpose, be far more elegant, and may come in handy for other uses down the road.  Perfect!

>>>>COMMIT<<<<

Database object as array of tables
Print database
Drop database

Update support
When deleting rows, we'll just mark them as deleted, then we'll have a COMPACT statement that goes in and cleans them up

Print out the results in a pretty fashion

Adapt API much closer to SQL syntax using varargs and such.

>>>>COMMIT<<<<<

Basic select support
Update support
Compact support

>>>>COMMIT<<<<<

Joins in selects

>>>>COMMIT<<<<<

SQL parser

>>>>COMMIT<<<<<

REPL and read from file

>>>>COMMIT<<<<<

Benchmarks against SQLite

>>>>COMMIT<<<<<

Improvements based on benchmarks (indexing?)

